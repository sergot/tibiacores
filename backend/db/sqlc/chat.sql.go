// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: chat.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO list_chat_messages (list_id, user_id, character_id, message)
VALUES ($1, $2, $3, $4)
RETURNING id, list_id, user_id, character_id, message, created_at
`

type CreateChatMessageParams struct {
	ListID      uuid.UUID `json:"list_id"`
	UserID      uuid.UUID `json:"user_id"`
	CharacterID uuid.UUID `json:"character_id"`
	Message     string    `json:"message"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ListChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ListID,
		arg.UserID,
		arg.CharacterID,
		arg.Message,
	)
	var i ListChatMessage
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.UserID,
		&i.CharacterID,
		&i.Message,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllChatMessages = `-- name: DeleteAllChatMessages :exec
DELETE FROM list_chat_messages
WHERE list_id = $1
`

func (q *Queries) DeleteAllChatMessages(ctx context.Context, listID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllChatMessages, listID)
	return err
}

const deleteChatMessage = `-- name: DeleteChatMessage :exec
DELETE FROM list_chat_messages
WHERE id = $1 AND user_id = $2
`

type DeleteChatMessageParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteChatMessage(ctx context.Context, arg DeleteChatMessageParams) error {
	_, err := q.db.Exec(ctx, deleteChatMessage, arg.ID, arg.UserID)
	return err
}

const getChatMessages = `-- name: GetChatMessages :many
SELECT 
    lcm.id,
    lcm.list_id,
    lcm.user_id,
    c.name as character_name,
    lcm.message,
    lcm.created_at
FROM list_chat_messages lcm
JOIN characters c ON lcm.character_id = c.id
WHERE lcm.list_id = $1
ORDER BY lcm.created_at DESC
LIMIT $2
OFFSET $3
`

type GetChatMessagesParams struct {
	ListID uuid.UUID `json:"list_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetChatMessagesRow struct {
	ID            uuid.UUID          `json:"id"`
	ListID        uuid.UUID          `json:"list_id"`
	UserID        uuid.UUID          `json:"user_id"`
	CharacterName string             `json:"character_name"`
	Message       string             `json:"message"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetChatMessages(ctx context.Context, arg GetChatMessagesParams) ([]GetChatMessagesRow, error) {
	rows, err := q.db.Query(ctx, getChatMessages, arg.ListID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatMessagesRow{}
	for rows.Next() {
		var i GetChatMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.UserID,
			&i.CharacterName,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMessagesByTimestamp = `-- name: GetChatMessagesByTimestamp :many
SELECT 
    lcm.id,
    lcm.list_id,
    lcm.user_id,
    c.name as character_name,
    lcm.message,
    lcm.created_at
FROM list_chat_messages lcm
JOIN characters c ON lcm.character_id = c.id
WHERE lcm.list_id = $1 AND lcm.created_at > $2
ORDER BY lcm.created_at ASC
`

type GetChatMessagesByTimestampParams struct {
	ListID    uuid.UUID          `json:"list_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type GetChatMessagesByTimestampRow struct {
	ID            uuid.UUID          `json:"id"`
	ListID        uuid.UUID          `json:"list_id"`
	UserID        uuid.UUID          `json:"user_id"`
	CharacterName string             `json:"character_name"`
	Message       string             `json:"message"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetChatMessagesByTimestamp(ctx context.Context, arg GetChatMessagesByTimestampParams) ([]GetChatMessagesByTimestampRow, error) {
	rows, err := q.db.Query(ctx, getChatMessagesByTimestamp, arg.ListID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatMessagesByTimestampRow{}
	for rows.Next() {
		var i GetChatMessagesByTimestampRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.UserID,
			&i.CharacterName,
			&i.Message,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatNotificationsForUser = `-- name: GetChatNotificationsForUser :many
WITH user_lists AS (
    SELECT DISTINCT l.id, l.name
    FROM lists l
    JOIN lists_users lu ON l.id = lu.list_id
    WHERE lu.user_id = $1
),
last_read_times AS (
    SELECT user_id, list_id, last_read_at
    FROM list_user_read_status
    WHERE user_id = $1
),
list_messages AS (
    SELECT 
        lcm.list_id, 
        ul.name as list_name,
        MAX(lcm.created_at) as last_message_time,
        COUNT(*) as unread_count,
        (
            SELECT c.name 
            FROM list_chat_messages lcm2
            JOIN characters c ON lcm2.character_id = c.id
            WHERE lcm2.list_id = lcm.list_id
            ORDER BY lcm2.created_at DESC
            LIMIT 1
        ) as last_character_name
    FROM list_chat_messages lcm
    JOIN user_lists ul ON lcm.list_id = ul.id
    LEFT JOIN last_read_times lrt ON lcm.list_id = lrt.list_id
    WHERE (lrt.last_read_at IS NULL OR lcm.created_at > lrt.last_read_at)
      AND lcm.user_id != $1 -- Don't count user's own messages as unread
    GROUP BY lcm.list_id, ul.name
    HAVING COUNT(*) > 0
)
SELECT 
    list_id,
    list_name,
    last_message_time,
    unread_count,
    last_character_name
FROM list_messages
ORDER BY last_message_time DESC
`

type GetChatNotificationsForUserRow struct {
	ListID            uuid.UUID   `json:"list_id"`
	ListName          string      `json:"list_name"`
	LastMessageTime   interface{} `json:"last_message_time"`
	UnreadCount       int64       `json:"unread_count"`
	LastCharacterName string      `json:"last_character_name"`
}

func (q *Queries) GetChatNotificationsForUser(ctx context.Context, userID uuid.UUID) ([]GetChatNotificationsForUserRow, error) {
	rows, err := q.db.Query(ctx, getChatNotificationsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatNotificationsForUserRow{}
	for rows.Next() {
		var i GetChatNotificationsForUserRow
		if err := rows.Scan(
			&i.ListID,
			&i.ListName,
			&i.LastMessageTime,
			&i.UnreadCount,
			&i.LastCharacterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markListMessagesAsRead = `-- name: MarkListMessagesAsRead :exec
INSERT INTO list_user_read_status (user_id, list_id, last_read_at)
VALUES ($1, $2, NOW())
ON CONFLICT (user_id, list_id) 
DO UPDATE SET last_read_at = NOW()
`

type MarkListMessagesAsReadParams struct {
	UserID uuid.UUID `json:"user_id"`
	ListID uuid.UUID `json:"list_id"`
}

func (q *Queries) MarkListMessagesAsRead(ctx context.Context, arg MarkListMessagesAsReadParams) error {
	_, err := q.db.Exec(ctx, markListMessagesAsRead, arg.UserID, arg.ListID)
	return err
}
