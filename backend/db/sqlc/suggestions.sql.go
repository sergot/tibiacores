// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: suggestions.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSoulcoreSuggestions = `-- name: CreateSoulcoreSuggestions :exec
WITH list_members AS (
    SELECT DISTINCT c.id as character_id, ls.creature_id, l.id as list_id
    FROM lists_users lu
    JOIN characters c ON c.user_id = lu.user_id
    JOIN lists l ON l.id = lu.list_id
    JOIN lists_soulcores ls ON ls.list_id = l.id
    WHERE l.id = $1 AND ls.creature_id = $2 AND ls.status = 'unlocked'
    AND NOT EXISTS (
        SELECT 1 FROM characters_soulcores cs 
        WHERE cs.character_id = c.id AND cs.creature_id = ls.creature_id
    )
)
INSERT INTO character_soulcore_suggestions (character_id, creature_id, list_id)
SELECT character_id, creature_id, list_id
FROM list_members
ON CONFLICT DO NOTHING
`

type CreateSoulcoreSuggestionsParams struct {
	ID         uuid.UUID `json:"id"`
	CreatureID uuid.UUID `json:"creature_id"`
}

func (q *Queries) CreateSoulcoreSuggestions(ctx context.Context, arg CreateSoulcoreSuggestionsParams) error {
	_, err := q.db.Exec(ctx, createSoulcoreSuggestions, arg.ID, arg.CreatureID)
	return err
}

const deleteSoulcoreSuggestion = `-- name: DeleteSoulcoreSuggestion :exec
DELETE FROM character_soulcore_suggestions
WHERE character_id = $1 AND creature_id = $2
`

type DeleteSoulcoreSuggestionParams struct {
	CharacterID uuid.UUID `json:"character_id"`
	CreatureID  uuid.UUID `json:"creature_id"`
}

func (q *Queries) DeleteSoulcoreSuggestion(ctx context.Context, arg DeleteSoulcoreSuggestionParams) error {
	_, err := q.db.Exec(ctx, deleteSoulcoreSuggestion, arg.CharacterID, arg.CreatureID)
	return err
}

const getCharacterSuggestions = `-- name: GetCharacterSuggestions :many
SELECT cs.character_id, cs.creature_id, cs.list_id, cs.suggested_at, c.name as creature_name
FROM character_soulcore_suggestions cs
JOIN creatures c ON c.id = cs.creature_id
WHERE cs.character_id = $1
ORDER BY cs.suggested_at DESC
`

type GetCharacterSuggestionsRow struct {
	CharacterID  uuid.UUID          `json:"character_id"`
	CreatureID   uuid.UUID          `json:"creature_id"`
	ListID       uuid.UUID          `json:"list_id"`
	SuggestedAt  pgtype.Timestamptz `json:"suggested_at"`
	CreatureName string             `json:"creature_name"`
}

func (q *Queries) GetCharacterSuggestions(ctx context.Context, characterID uuid.UUID) ([]GetCharacterSuggestionsRow, error) {
	rows, err := q.db.Query(ctx, getCharacterSuggestions, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCharacterSuggestionsRow{}
	for rows.Next() {
		var i GetCharacterSuggestionsRow
		if err := rows.Scan(
			&i.CharacterID,
			&i.CreatureID,
			&i.ListID,
			&i.SuggestedAt,
			&i.CreatureName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingSuggestionsForUser = `-- name: GetPendingSuggestionsForUser :many
SELECT 
    c.id as character_id,
    c.name as character_name,
    COUNT(cs.creature_id) as suggestion_count
FROM characters c
JOIN character_soulcore_suggestions cs ON cs.character_id = c.id
WHERE c.user_id = $1
GROUP BY c.id, c.name
`

type GetPendingSuggestionsForUserRow struct {
	CharacterID     uuid.UUID `json:"character_id"`
	CharacterName   string    `json:"character_name"`
	SuggestionCount int64     `json:"suggestion_count"`
}

func (q *Queries) GetPendingSuggestionsForUser(ctx context.Context, userID uuid.UUID) ([]GetPendingSuggestionsForUserRow, error) {
	rows, err := q.db.Query(ctx, getPendingSuggestionsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingSuggestionsForUserRow{}
	for rows.Next() {
		var i GetPendingSuggestionsForUserRow
		if err := rows.Scan(&i.CharacterID, &i.CharacterName, &i.SuggestionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
